<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tomotargz.log</title><link>https://tomotargz.github.io/</link><description>Recent content on tomotargz.log</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 03 Jan 2023 00:08:48 +0900</lastBuildDate><atom:link href="https://tomotargz.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>データ指向アプリケーションデザイン読書メモ - リレーショナル・データベースとドキュメント・データベース</title><link>https://tomotargz.github.io/posts/%E3%83%87%E3%83%BC%E3%82%BF%E6%8C%87%E5%90%91%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E8%AA%AD%E6%9B%B8%E3%83%A1%E3%83%A2_%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%A8%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9/</link><pubDate>Tue, 03 Jan 2023 00:08:48 +0900</pubDate><guid>https://tomotargz.github.io/posts/%E3%83%87%E3%83%BC%E3%82%BF%E6%8C%87%E5%90%91%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E8%AA%AD%E6%9B%B8%E3%83%A1%E3%83%A2_%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%A8%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9/</guid><description>年末年始にデータ指向アプリケーションデザインを読み進めた。リレーショナル・データベースとドキュメント・データベースの違いについてランダムにメモ。
データの多重度 1:N ドキュメント・データベースは多重度が1:Nのデータを1レコードで表現できる。
{ &amp;#34;name&amp;#34;: &amp;#34;tomotargz&amp;#34;, &amp;#34;work_experience&amp;#34;: [ { &amp;#34;company&amp;#34;: &amp;#34;Awesome company&amp;#34;, &amp;#34;position&amp;#34;: &amp;#34;Software engineer&amp;#34; }, { &amp;#34;company&amp;#34;: &amp;#34;Great company&amp;#34;, &amp;#34;position&amp;#34;: &amp;#34;Manager&amp;#34; } ] } 対してリレーショナル・データベースは複数のレコードを結合しなければならない。
user table
id name 1 tomotargz work_experience table
id company position user_id 1 Awesome company Software Engineer 1 2 Great company Manager 1 1:Nのデータを扱う場合、ドキュメント・データベースはlocalityを活かせるので読み取りのパフォーマンスが高い。
N:1, N:N 多重度がN:1やN:Nのデータを扱う場合、ドキュメント・データベースは結合をエミュレートするか非正規化しなければならない。
結合 ドキュメント・データベースは結合のサポートが弱い。多くの場合、データベースではなくアプリケーション側で結合しなければならない。通常、アプリケーションによる結合はデータベースによる結合よりも時間がかかる。
スキーマ ドキュメント・データベースはスキーマレスと言われることがあるが正確ではない。アプリケーションはスキーマを暗黙のうちに想定してデータを読み取る。そのため、正確にはドキュメント・データベースはスキーマオンリードであると言える。対して、リレーショナル・データベースはスキーマ・オンライトである。
ドキュメント・データベースはデータのフォーマット変更に対応しやすい。例えばnameフィールドをfirst_nameとlast_nameに分けなければならないとき、リレーショナル・データベースでは一般的にスキーマの変更が必要になるが、ドキュメント・データベースではアプリケーションが読み取り時に動的にfirst_nameとlast_nameを作成する(first_namtとlast_nameが存在しなかったらnameを元に作成する)アプローチを取れる。もっとも、リレーショナル・データベースでも同様のことが可能なので、大きな違いとは言いにくい。
何らかの理由でデータのフォーマットが統一されていないときは、ドキュメント・データベースを使うメリットが生まれる。以下のようなケースが考えられる。
多くの種類のオブジェクトがあり、それぞれに専用のテーブルを作成することが現実的でない場合。 データのフォーマットが外部のシステムに決定され、いつ変更されるかわからない場合。 インピーダンスミスマッチ 多くのアプリケーションはオブジェクト指向で設計されている。オブジェクト指向におけるデータモデルはリレーショナル・データベースとは異なる。そのため多くの場合、リレーショナル・データベースとアプリケーションの間に変換レイヤーが必要になる。このデータモデルの違いはインピーダンスミスマッチと呼ばれることがある。
アプリケーションが扱うデータがドキュメントのような構造(多重度が1:Nのツリー構造を持ち、ツリー全体が一度にロードされる)を持っている場合、ドキュメント・データベースを使うことでアプリケーションコードを単純化できる。そうでない場合、アプリケーションで結合をエミュレートしなければならない。結合を避けるために非正規化すると、データの整合性を保つためのコードが必要になる。ドキュメント・データベースがインピーダンスミスマッチを軽減するとは一概には言えない。</description></item><item><title>Traverseする関数の書き方</title><link>https://tomotargz.github.io/posts/traverse%E3%81%99%E3%82%8B%E9%96%A2%E6%95%B0%E3%81%AE%E6%9B%B8%E3%81%8D%E6%96%B9/</link><pubDate>Mon, 02 Jan 2023 22:57:24 +0900</pubDate><guid>https://tomotargz.github.io/posts/traverse%E3%81%99%E3%82%8B%E9%96%A2%E6%95%B0%E3%81%AE%E6%9B%B8%E3%81%8D%E6%96%B9/</guid><description>グラフを探索するコードを書くときに、base-caseをどこで判定すべきか迷うことがある。 例えば2分木をpre-orderで探索して各ノードが持つ値の合計を計算する関数traverseを書こうとするとき、以下3つの選択肢があるように思う。
// 関数の先頭でbase-caseを判定 int traverse1(TreeNode* root){ if(!root) return 0; int sum = root-&amp;gt;val; sum += traverse(root-&amp;gt;left); sum += traverse(root-&amp;gt;right); return sum; } // 再帰呼び出しの前でbase-caseを判定 int traverse2(TreeNode* root){ int sum = root-&amp;gt;val; if(root-&amp;gt;left) sum += traverse(root-&amp;gt;left); if(root-&amp;gt;right) sum += traverse(root-&amp;gt;right); return sum; } // 関数の先頭と再帰呼び出しの前でbase-caseを判定 int traverse3(TreeNode* root){ if(!root) return 0; int sum = root-&amp;gt;val; if(root-&amp;gt;left) sum += traverse(root-&amp;gt;left); if(root-&amp;gt;right) sum += traverse(root-&amp;gt;right); return sum; } traverse1が最もシンプルな書き方だろう。ただし、base-case判定に関数呼び出しが必要なため、base-case判定の計算コストが高い。また、base-caseの戻り値が自明でない場合、何かしらの設計が必要になる(例えばtraverseが子ノードの数を返す関数だった場合、そもそも親がnullのときは何を返せば良いのだろう？)。さらに、細かいが時間計算量を求めるために再帰呼び出しのツリーを可視化したときに、base-caseとそうでないときで計算量が異なるため、考えることが増える。 traverse2はbase-caseを判定するときにわざわざ関数を呼び出さなくて済むため、base-case判定の計算コストが低い。また、base-caseで呼び出されることがないため、base-caseのときの戻り値を考えなくて済む。さらに、どんなときでも呼び出しあたりの計算量が等しいため、時間計算量を求めようとしたときに考えることが少ない。ただし、初回呼び出しのときに呼び出し側でbase-caseを判定しなければならない。 tracerse3は1と2のハイブリッド案。 探索するグラフ・各ノードで行う処理・base-caseに合わせてどれを選択するか決めれば良いのだろう。私の経験的には、戻り値があり、base-caseのときの戻り値が自明でないときは2、その他の場合は1で書くと混乱せずに関数を書ききれる。少しでも計算コストを下げたいなら2。計算量解析は、まあ関数の詳細ではなく、その意図から考えるようにすればどの書き方であっても混乱しない。</description></item><item><title>連結グラフから連結性を保ったままノードを取り除く</title><link>https://tomotargz.github.io/posts/%E9%80%A3%E7%B5%90%E3%82%B0%E3%83%A9%E3%83%95%E3%81%8B%E3%82%89%E9%80%A3%E7%B5%90%E6%80%A7%E3%82%92%E4%BF%9D%E3%81%A3%E3%81%9F%E3%81%BE%E3%81%BE%E3%83%8E%E3%83%BC%E3%83%89%E3%82%92%E5%8F%96%E3%82%8A%E9%99%A4%E3%81%8F/</link><pubDate>Thu, 29 Dec 2022 00:17:36 +0900</pubDate><guid>https://tomotargz.github.io/posts/%E9%80%A3%E7%B5%90%E3%82%B0%E3%83%A9%E3%83%95%E3%81%8B%E3%82%89%E9%80%A3%E7%B5%90%E6%80%A7%E3%82%92%E4%BF%9D%E3%81%A3%E3%81%9F%E3%81%BE%E3%81%BE%E3%83%8E%E3%83%BC%E3%83%89%E3%82%92%E5%8F%96%E3%82%8A%E9%99%A4%E3%81%8F/</guid><description>連結グラフからノードをひとつずつ取り除くことを考える。このとき、連結性を保ったまま、ノード数が1になるまでグラフを小さくできる。
ノードを取り除く順番次第で、グラフが連結ではなくなってしまう。例えば上の図で最初にEを取り除くと、グラフが連結ではなくなる。では連結性を保ちたいとき、どのような順番でノードを取り除けばよいか？
グラフのあるノードからBFSもしくはDFSをすると木ができる。この木の葉をひとつずつ摘んでいくと、最終的に根が残る。木の葉を摘むときに、元のグラフの対応するノードを削除していくと、連結性を保ったままノード数を減らし続けることができる。以下は元のグラフをAからDFSしたときにできる木を示している。
D,F,B,E,Cの順に葉を摘むと、元のグラフが1枚目の画像のように遷移する。
(参考) LeetCode 947. Most Stones Removed with Same Row or Column</description></item><item><title>About this blog</title><link>https://tomotargz.github.io/posts/about-this-blog/</link><pubDate>Tue, 27 Dec 2022 23:41:52 +0900</pubDate><guid>https://tomotargz.github.io/posts/about-this-blog/</guid><description>このブログはtomotargzが学んだこと、考えたこと、感じたことを記録する場所です。</description></item></channel></rss>