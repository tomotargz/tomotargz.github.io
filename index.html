<!doctype html><html lang=ja-jp><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>tomotargz.log</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content><meta name=generator content="Hugo 0.109.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><link href=/index.xml rel=alternate type=application/rss+xml title=tomotargz.log><link href=/index.xml rel=feed type=application/rss+xml title=tomotargz.log><meta property="og:title" content="tomotargz.log"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://tomotargz.github.io/"><meta itemprop=name content="tomotargz.log"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="tomotargz.log"><meta name=twitter:description content></head><body class="ma0 avenir bg-near-white"><header><div class="pb3-m pb6-l bg-black"><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">tomotargz.log</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav><div class="tc-l pv3 ph3 ph4-ns"><h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">tomotargz.log</h1></div></div></header><main class=pb7 role=main><article class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></article><div class="pa3 pa4-ns w-100 w-70-ns center"><h1 class=flex-none>Recent Posts</h1><section class="w-100 mw8"><div class="relative w-100 mb4"><article class="bb b--black-10"><div class="db pv4 ph3 ph0-l no-underline dark-gray"><div class="flex flex-column flex-row-ns"><div class="blah w-100"><h1 class="f3 fw1 athelas mt0 lh-title"><a href=/posts/%E3%83%87%E3%83%BC%E3%82%BF%E6%8C%87%E5%90%91%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E8%AA%AD%E6%9B%B8%E3%83%A1%E3%83%A2_%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%A8%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9/ class="color-inherit dim link">データ指向アプリケーションデザイン読書メモ - リレーショナル・データベースとドキュメント・データベース</a></h1><div class="f6 f5-l lh-copy nested-copy-line-height nested-links">年末年始にデータ指向アプリケーションデザインを読み進めた。リレーショナル・データベースとドキュメント・データベースの違いについてランダムにメモ。
データの多重度 1:N ドキュメント・データベースは多重度が1:Nのデータを1レコードで表現できる。
{ "name": "tomotargz", "work_experience": [ { "company": "Awesome company", "position": "Software engineer" }, { "company": "Great company", "position": "Manager" } ] } 対してリレーショナル・データベースは複数のレコードを結合しなければならない。
user table
id name 1 tomotargz work_experience table
id company position user_id 1 Awesome company Software Engineer 1 2 Great company Manager 1 1:Nのデータを扱う場合、ドキュメント・データベースはlocalityを活かせるので読み取りのパフォーマンスが高い。
N:1, N:N 多重度がN:1やN:Nのデータを扱う場合、ドキュメント・データベースは結合をエミュレートするか非正規化しなければならない。
結合 ドキュメント・データベースは結合のサポートが弱い。多くの場合、データベースではなくアプリケーション側で結合しなければならない。通常、アプリケーションによる結合はデータベースによる結合よりも時間がかかる。
スキーマ ドキュメント・データベースはスキーマレスと言われることがあるが正確ではない。アプリケーションはスキーマを暗黙のうちに想定してデータを読み取る。そのため、正確にはドキュメント・データベースはスキーマオンリードであると言える。対して、リレーショナル・データベースはスキーマ・オンライトである。
ドキュメント・データベースはデータのフォーマット変更に対応しやすい。例えばnameフィールドをfirst_nameとlast_nameに分けなければならないとき、リレーショナル・データベースでは一般的にスキーマの変更が必要になるが、ドキュメント・データベースではアプリケーションが読み取り時に動的にfirst_nameとlast_nameを作成する(first_namtとlast_nameが存在しなかったらnameを元に作成する)アプローチを取れる。もっとも、リレーショナル・データベースでも同様のことが可能なので、大きな違いとは言いにくい。
何らかの理由でデータのフォーマットが統一されていないときは、ドキュメント・データベースを使うメリットが生まれる。以下のようなケースが考えられる。
多くの種類のオブジェクトがあり、それぞれに専用のテーブルを作成することが現実的でない場合。 データのフォーマットが外部のシステムに決定され、いつ変更されるかわからない場合。 インピーダンスミスマッチ 多くのアプリケーションはオブジェクト指向で設計されている。オブジェクト指向におけるデータモデルはリレーショナル・データベースとは異なる。そのため多くの場合、リレーショナル・データベースとアプリケーションの間に変換レイヤーが必要になる。このデータモデルの違いはインピーダンスミスマッチと呼ばれることがある。
アプリケーションが扱うデータがドキュメントのような構造(多重度が1:Nのツリー構造を持ち、ツリー全体が一度にロードされる)を持っている場合、ドキュメント・データベースを使うことでアプリケーションコードを単純化できる。そうでない場合、アプリケーションで結合をエミュレートしなければならない。結合を避けるために非正規化すると、データの整合性を保つためのコードが必要になる。ドキュメント・データベースがインピーダンスミスマッチを軽減するとは一概には言えない。</div><a href=/posts/%E3%83%87%E3%83%BC%E3%82%BF%E6%8C%87%E5%90%91%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E8%AA%AD%E6%9B%B8%E3%83%A1%E3%83%A2_%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%A8%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9/ class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a></div></div></div></article></div><div class="relative w-100 mb4"><article class="bb b--black-10"><div class="db pv4 ph3 ph0-l no-underline dark-gray"><div class="flex flex-column flex-row-ns"><div class="blah w-100"><h1 class="f3 fw1 athelas mt0 lh-title"><a href=/posts/traverse%E3%81%99%E3%82%8B%E9%96%A2%E6%95%B0%E3%81%AE%E6%9B%B8%E3%81%8D%E6%96%B9/ class="color-inherit dim link">Traverseする関数の書き方</a></h1><div class="f6 f5-l lh-copy nested-copy-line-height nested-links">グラフを探索するコードを書くときに、base-caseをどこで判定すべきか迷うことがある。 例えば2分木をpre-orderで探索して各ノードが持つ値の合計を計算する関数traverseを書こうとするとき、以下3つの選択肢があるように思う。
// 関数の先頭でbase-caseを判定 int traverse1(TreeNode* root){ if(!root) return 0; int sum = root->val; sum += traverse(root->left); sum += traverse(root->right); return sum; } // 再帰呼び出しの前でbase-caseを判定 int traverse2(TreeNode* root){ int sum = root->val; if(root->left) sum += traverse(root->left); if(root->right) sum += traverse(root->right); return sum; } // 関数の先頭と再帰呼び出しの前でbase-caseを判定 int traverse3(TreeNode* root){ if(!root) return 0; int sum = root->val; if(root->left) sum += traverse(root->left); if(root->right) sum += traverse(root->right); return sum; } traverse1が最もシンプルな書き方だろう。ただし、base-case判定に関数呼び出しが必要なため、base-case判定の計算コストが高い。また、base-caseの戻り値が自明でない場合、何かしらの設計が必要になる(例えばtraverseが子ノードの数を返す関数だった場合、そもそも親がnullのときは何を返せば良いのだろう？)。さらに、細かいが時間計算量を求めるために再帰呼び出しのツリーを可視化したときに、base-caseとそうでないときで計算量が異なるため、考えることが増える。 traverse2はbase-caseを判定するときにわざわざ関数を呼び出さなくて済むため、base-case判定の計算コストが低い。また、base-caseで呼び出されることがないため、base-caseのときの戻り値を考えなくて済む。さらに、どんなときでも呼び出しあたりの計算量が等しいため、時間計算量を求めようとしたときに考えることが少ない。ただし、初回呼び出しのときに呼び出し側でbase-caseを判定しなければならない。 tracerse3は1と2のハイブリッド案。 探索するグラフ・各ノードで行う処理・base-caseに合わせてどれを選択するか決めれば良いのだろう。私の経験的には、戻り値があり、base-caseのときの戻り値が自明でないときは2、その他の場合は1で書くと混乱せずに関数を書ききれる。少しでも計算コストを下げたいなら2。計算量解析は、まあ関数の詳細ではなく、その意図から考えるようにすればどの書き方であっても混乱しない。</div><a href=/posts/traverse%E3%81%99%E3%82%8B%E9%96%A2%E6%95%B0%E3%81%AE%E6%9B%B8%E3%81%8D%E6%96%B9/ class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a></div></div></div></article></div><div class="relative w-100 mb4"><article class="bb b--black-10"><div class="db pv4 ph3 ph0-l no-underline dark-gray"><div class="flex flex-column flex-row-ns"><div class="blah w-100"><h1 class="f3 fw1 athelas mt0 lh-title"><a href=/posts/%E9%80%A3%E7%B5%90%E3%82%B0%E3%83%A9%E3%83%95%E3%81%8B%E3%82%89%E9%80%A3%E7%B5%90%E6%80%A7%E3%82%92%E4%BF%9D%E3%81%A3%E3%81%9F%E3%81%BE%E3%81%BE%E3%83%8E%E3%83%BC%E3%83%89%E3%82%92%E5%8F%96%E3%82%8A%E9%99%A4%E3%81%8F/ class="color-inherit dim link">連結グラフから連結性を保ったままノードを取り除く</a></h1><div class="f6 f5-l lh-copy nested-copy-line-height nested-links">連結グラフからノードをひとつずつ取り除くことを考える。このとき、連結性を保ったまま、ノード数が1になるまでグラフを小さくできる。
ノードを取り除く順番次第で、グラフが連結ではなくなってしまう。例えば上の図で最初にEを取り除くと、グラフが連結ではなくなる。では連結性を保ちたいとき、どのような順番でノードを取り除けばよいか？
グラフのあるノードからBFSもしくはDFSをすると木ができる。この木の葉をひとつずつ摘んでいくと、最終的に根が残る。木の葉を摘むときに、元のグラフの対応するノードを削除していくと、連結性を保ったままノード数を減らし続けることができる。以下は元のグラフをAからDFSしたときにできる木を示している。
D,F,B,E,Cの順に葉を摘むと、元のグラフが1枚目の画像のように遷移する。
(参考) LeetCode 947. Most Stones Removed with Same Row or Column</div><a href=/posts/%E9%80%A3%E7%B5%90%E3%82%B0%E3%83%A9%E3%83%95%E3%81%8B%E3%82%89%E9%80%A3%E7%B5%90%E6%80%A7%E3%82%92%E4%BF%9D%E3%81%A3%E3%81%9F%E3%81%BE%E3%81%BE%E3%83%8E%E3%83%BC%E3%83%89%E3%82%92%E5%8F%96%E3%82%8A%E9%99%A4%E3%81%8F/ class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a></div></div></div></article></div></section><section class=w-100><h1 class=f3>More</h1><h2 class="f5 fw4 mb4 dib mr3"><a href=/posts/about-this-blog/ class="link black dim">About this blog</a></h2><a href=/posts/ class="link db f6 pa2 br3 bg-mid-gray white dim w4 tc">All Posts</a></section></div></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://tomotargz.github.io/>&copy; tomotargz.log 2023</a><div><div class=ananke-socials></div></div></div></footer></body></html>